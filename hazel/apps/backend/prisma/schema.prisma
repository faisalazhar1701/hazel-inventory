generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id        String         @id @default(uuid())
  email     String         @unique
  role      String         // ADMIN, PRODUCT_MANAGER, PRODUCTION_MANAGER, WAREHOUSE_STAFF, SALES_REP, FINANCE, RETAIL_STAFF, CUSTOMER_USER
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  customerUsers CustomerUser[]

  @@map("users")
}

model Customer {
  id          String        @id @default(uuid())
  type        String        // RETAIL, B2B, WHOLESALE
  companyName String
  status      String        @default("ACTIVE") // ACTIVE, INACTIVE, SUSPENDED
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  orders      Order[]
  customerUsers CustomerUser[]

  @@map("customers")
}

model CustomerUser {
  id         String   @id @default(uuid())
  userId     String
  customerId String
  role       String   // ADMIN, MANAGER, VIEWER - role within the customer organization
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@unique([userId, customerId])
  @@map("customer_users")
}

model Collection {
  id       String    @id @default(uuid())
  name     String
  season   String?
  year     Int?
  drops    Drop[]
  products Product[]

  @@map("collections")
}

model Drop {
  id           String      @id @default(uuid())
  name         String
  releaseDate  DateTime?
  collectionId String?
  collection   Collection? @relation(fields: [collectionId], references: [id], onDelete: SetNull)

  @@map("drops")
}

model Style {
  id        String   @id @default(uuid())
  name      String
  code      String?
  productId String?
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@unique([productId])
  @@map("styles")
}

model Product {
  id              String           @id @default(uuid())
  name            String
  sku             String           @unique
  description     String?
  lifecycleStatus String           @default("DRAFT") // DRAFT, ACTIVE, DISCONTINUED
  collectionId    String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  collection      Collection?      @relation(fields: [collectionId], references: [id], onDelete: SetNull)
  style           Style?
  variants        ProductVariant[]

  @@map("products")
}

model ProductVariant {
  id             String           @id @default(uuid())
  productId      String
  sku            String           @unique
  attributes     String? // JSON stored as text for SQLite
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  product        Product          @relation(fields: [productId], references: [id], onDelete: Cascade)
  inventoryItems InventoryItem[]
  orderItems     OrderItem[]
  bomAsParent    BillOfMaterial[] @relation("ParentVariant")
  bomAsComponent BillOfMaterial[] @relation("ComponentVariant")
  demandForecasts DemandForecast[]
  replenishmentSuggestions ReplenishmentSuggestion[]

  @@map("product_variants")
}

model BillOfMaterial {
  id                 String         @id @default(uuid())
  parentVariantId    String
  componentVariantId String
  quantity           Float
  parentVariant      ProductVariant @relation("ParentVariant", fields: [parentVariantId], references: [id], onDelete: Cascade)
  componentVariant   ProductVariant @relation("ComponentVariant", fields: [componentVariantId], references: [id], onDelete: Cascade)

  @@unique([parentVariantId, componentVariantId])
  @@map("bill_of_materials")
}

model Warehouse {
  id             String          @id @default(uuid())
  name           String
  location       String
  fulfillments   Fulfillment[]
  inventoryItems InventoryItem[]
  replenishmentSuggestions ReplenishmentSuggestion[]

  @@map("warehouses")
}

model InventoryItem {
  id               String                 @id @default(uuid())
  productVariantId String
  warehouseId      String
  quantity         Int
  itemType         String
  warehouse        Warehouse              @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  productVariant   ProductVariant         @relation(fields: [productVariantId], references: [id], onDelete: Cascade)
  ledgerEntries    InventoryLedger[]
  reservations     InventoryReservation[]

  @@unique([productVariantId, warehouseId])
  @@map("inventory_items")
}

model InventoryLedger {
  id              String        @id @default(uuid())
  inventoryItemId String
  changeQuantity  Int
  reason          String
  createdAt       DateTime      @default(now())
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  @@map("inventory_ledger")
}

model InventoryReservation {
  id               String        @id @default(uuid())
  orderId          String
  orderItemId      String
  inventoryItemId  String
  productVariantId String
  warehouseId      String
  quantity         Int
  reservedAt       DateTime      @default(now())
  consumedAt       DateTime?
  releasedAt       DateTime?
  order            Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderItem        OrderItem     @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  inventoryItem    InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  @@unique([orderId, orderItemId, warehouseId])
  @@index([orderId])
  @@index([productVariantId, warehouseId])
  @@index([inventoryItemId])
  @@map("inventory_reservations")
}

model Order {
  id                    String                 @id @default(uuid())
  orderNumber           String                 @unique
  channel               String
  customerId            String?
  status                String // DRAFT, CONFIRMED, ALLOCATED, SHIPPED, DELIVERED, COMPLETED, FULFILLED, CANCELLED, RETURNED
  totalAmount           Float
  currency              String
  confirmedAt           DateTime?
  allocatedAt           DateTime?
  shippedAt             DateTime?
  deliveredAt           DateTime?
  completedAt           DateTime?
  fulfilledAt           DateTime?
  cancelledAt           DateTime?
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  customer              Customer?              @relation(fields: [customerId], references: [id], onDelete: SetNull)
  fulfillments          Fulfillment[]
  orderItems            OrderItem[]
  inventoryReservations InventoryReservation[]

  @@map("orders")
}

model OrderItem {
  id               String                 @id @default(uuid())
  orderId          String
  productVariantId String
  quantity         Int
  unitPrice        Float
  totalPrice       Float
  productVariant   ProductVariant         @relation(fields: [productVariantId], references: [id], onDelete: Cascade)
  order            Order                  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  reservations     InventoryReservation[]

  @@map("order_items")
}

model Fulfillment {
  id          String    @id @default(uuid())
  orderId     String
  warehouseId String
  status      String
  shippedAt   DateTime?
  warehouse   Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  order       Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@map("fulfillments")
}

model DemandForecast {
  id                String        @id @default(uuid())
  productVariantId  String
  periodStart       DateTime
  periodEnd         DateTime
  forecastQuantity  Int
  channel           String?       // Optional: DTC, B2B, POS, WHOLESALE, RETAIL
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  productVariant    ProductVariant @relation(fields: [productVariantId], references: [id], onDelete: Cascade)

  @@index([productVariantId])
  @@index([periodStart, periodEnd])
  @@map("demand_forecasts")
}

model ReplenishmentSuggestion {
  id                 String        @id @default(uuid())
  productVariantId   String
  warehouseId        String
  recommendedQuantity Int
  recommendedDate    DateTime
  reason             String        // LOW_STOCK, FORECAST_DEMAND, SEASONAL, etc.
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  productVariant     ProductVariant @relation(fields: [productVariantId], references: [id], onDelete: Cascade)
  warehouse          Warehouse      @relation(fields: [warehouseId], references: [id], onDelete: Cascade)

  @@index([productVariantId, warehouseId])
  @@index([recommendedDate])
  @@map("replenishment_suggestions")
}
